{
    "submission": [
        {
            "semantics_correct": "# compile-errors:success: Compilation Successful #\n# compile-result:1 #\n# save-event:compile #\ndef IsPrime(x):\n    p=0\n    for i in range(1,x+1):\n        if (x%i)==0:\n            p=p+1\n    if p==2:\n        return True\n    else:\n        return False\n\n       \ndef Reverse(x):\n    while x%10==0:\n        x=x//10\n    q=0\n    while(x!=0):\n        r=x%10\n        q=q*10+r\n        x= x//10\n    return q\n\n\ndef decrypt(n1,n2):\n    X=Reverse(n1)\n    Y=Reverse(n2)\n    if IsPrime(X) and IsPrime(Y):\n        return X+Y\n    elif IsPrime(X) or IsPrime(Y):\n        return n1+n2\n    else:\n        return n1*n2\n   \npassword=input()\ndec=password.split(',')\nA=int(dec[0])\nB=int(dec[1])\nprint(decrypt(A,B))\n",
            "syntax_incorrect": "# compile-errors:success: Compilation Successful #\n# compile-result:1 #\n# save-event:compile #\na=int(input())\nb=int(input())\nn=str(a)\nm=str(b)\nn1=n[::-1]\nm1=m[::-1]\nx=int(n1)\ny=int(m1)\nif x>1:\n    for i in range(2, x):\n        if (x%i)==0:\n            p=0\n            break\n        else:\n            p=1\nelse:\n    p=0\nif y>1:\n    for j in range(2, y):\n        if (y%j)==0:\n            q=0\n            break\n        else:\n            q=1\nelse:\n    q=0\nif p==1 and q==1:\n    g=x+y\n    print(g)\nelif p=1 or p=1:\n    h=a+b\n    print(h)\nelse:\n    print(a*b)\n"
        },
        {
            "semantics_correct": "# compile-errors:success: Compilation Successful #\n# compile-result:1 #\n# save-event:compile #\ndef isprime(num,i=2):\n    if num <= 2:\n        return True if num == 2 else False\n    if num % i == 0:\n        return False\n    if (i * i > num): \n        return True \n    return isprime(num,i+1)\n    \ndef numrev(num):\n    numstr=str(num)\n    reversed=int(numstr[::-1])\n    return reversed\n    \ndef result(num1, num2):\n\tif (isprime(num1) and isprime(num2)):\n\t\tprint(num1 + num2)\n\telif (isprime(num1) or isprime(num2)):\n\t\tprint(numrev(num1) + numrev(num2))\n\telse:\n\t\tprint(numrev(num1) * numrev(num2))\n    \ndata = str(input())\nnumList = data.split(',')\nnum1 = numrev(int(numList[0].strip()))\nnum2 = numrev(int(numList[1].strip()))\nresult(num1, num2)",
            "syntax_incorrect": "# compile-errors:success: Compilation Successful #\n# compile-result:1 #\n# save-event:compile #\ndef isprime(num,i=2):\n    if num <= 1:\n        return False\n    if num == i:\n        return True\n    if num % i == 0:\n        return False\n    i+=1\n    return isprime(num,i)\n    \ndef numrev(num):\n    numstr=str(num)\n    reversed=int(0)\n    if numstr[0]==\"-\":\n\t    reversed=int(\"-\"+numstr[-1:0:-1])\n    else:\n    \treversed=int(numstr[::-1])\n    return reversed\n    \ndef result(num1, num 2):\nif (isprime(num1) and isprime(num2)):\n\tprint(num1 + num2)\nelif (isprime(num1) or isprime(num2)):\n\tprint(numrev(num1) + numrev(num2))\nelse:\n\tprint(numrev(num1) * numrev(num2))\n    \ndata = str(input())\nnumList = data.split(',')\nnum1 = numrev(int(numList[0].strip()))\nnum2 = numrev(int(numList[1].strip()))\nresult(num1, num2)"
        },
        {
            "semantics_correct": "# compile-errors:success: Compilation Successful #\n# compile-result:1 #\n# save-event:compile #\nlst = input().split(',')\na=lst[0]\nb=lst[1]\ndef prime_chk(num):\n    if num > 1:\n        for i in range(2,num):\n            if (num % i) == 0:\n                return False\n                break\n        else:\n            return True\n    else:\n        return False\ndef decrypter(a,b):\n    x,y = a[::-1], b[::-1]\n    x,y=int(x),int(y)\n    px,py = prime_chk(x),prime_chk(y) \n    if px and py:\n        answer = x+y\n    elif px or py:\n        answer = int(a)+int(b)\n    else:\n        answer = int(a)*int(b)\n    return answer\nprint(decrypter(a,b))\n",
            "syntax_incorrect": "# compile-errors:success: Compilation Successful #\n# compile-result:1 #\n# save-event:compile #\n1st\n\nlst = input().split(',')\na=lst[0]\nb=lst[1]\ndef prime_chk(num):\n    if num > 1:\n        for i in range(2,num):\n            if (num % i) == 0:\n                return False\n                break\n        else:\n            return True\n    else:\n        return False\ndef decrypter(a,b):\n    x,y = a[::-1], b[::-1]\n    x,y=int(x),int(y)\n    px,py = prime_chk(x),prime_chk(y) \n    if px and py:\n        answer = x+y\n    elif px or py:\n        answer = int(a)+int(b)\n    else:\n        answer = int(a)*int(b)\n    return answer\nprint(decrypter(a,b))\n"
        },
        {
            "semantics_correct": "# compile-errors:success: Compilation Successful #\n# compile-result:1 #\n# save-event:compile #\ndef IsPrime(x):\n    count=0\n    for i in range(1,x+1):\n        if (x%i)==0:\n            count=count+1\n    if count==2:\n        return True\n    else:\n        return False\n\n       \ndef Reverse(x):\n    while x%10==0:\n        x=x//10\n    rev=0\n    while(x!=0):\n        r=x%10\n        rev=rev*10+r\n        x= x//10\n    return rev\n\n\ndef decrypt(num1,num2):\n    X=Reverse(num1)\n    Y=Reverse(num2)\n    if IsPrime(X) and IsPrime(Y):\n        return X+Y\n    elif IsPrime(X) or IsPrime(Y):\n        return num1+num2\n    else:\n        return num1*num2\n   \npassword=input()\ndec=password.split(',')\nA=int(dec[0])\nB=int(dec[1])\nprint(decrypt(A,B))",
            "syntax_incorrect": "# compile-errors:success: Compilation Successful #\n# compile-result:1 #\n# save-event:compile #\na, b = input().split(',')\nx, ydef rev_number(n):\n  s = 0\n  while True:\n    k = str(n)\n    if k == k[::-1]:\n      break\n    else:\n      m = int(k[::-1])\n      n += m\n      s += 1\n  return n "
        },
        {
            "semantics_correct": "# compile-errors:success: Compilation Successful #\n# compile-result:1 #\n# save-event:compile #\ndef isPrime(num):\n    if num<=1:\n        return False\n    for i in range(2, num):\n        if (num % i) == 0:\n            return False\n    return True\n            \na,b = input().split(',')\nx = int(a[::-1])\ny = int(b[::-1])\n\nif (isPrime(x) and isPrime(y)):\n    print(x+y)\n\nelif (isPrime(x) or isPrime(y)):\n    print(int(a)+int(b))\nelse:\n    print(int(a)*int(b))",
            "syntax_incorrect": "# compile-errors:success: Compilation Successful #\n# compile-result:1 #\n# save-event:compile #\ndef is Prime(num):\n    if num<=1:\n        return False\n    for i in range(2, num):\n        if (num % i) == 0:\n            return False\n    return True\n            \na,b = input().split(',')\nx = int(a[::-1])\ny = int(b[::-1])\n\nif (isPrime(x) and isPrime(y)):\n    print(x+y)\n\nelif (isPrime(x) or isPrime(y)):\n    print(int(a)+int(b))\nelse:\n    print(int(a)*int(b))\n[1:43 PM, 1/21/2021] Apoorva Mishra: def a(m,n):\n    if m == 0:\n        return (n + 1)\n    if n == 0:\n        return a(m-1,1)\n    return a(m-1,a(m,n-1))\n    \nx,y = input().split(',')\nm,n = int(x),int(y)\nprint(a(m,n))"
        },
        {
            "semantics_correct": "# compile-errors:success: Compilation Successful #\n# compile-result:1 #\n# save-event:compile #\ndef isPrime(num):\n    if num<=1:\n        return False\n    for i in range(2, num):\n        if (num % i) == 0:\n            return False\n    return True\n            \na,b = input().split(',')\nx = int(a[::-1])\ny = int(b[::-1])\n\nif (isPrime(x) and isPrime(y)):\n    print(x+y)\n\nelif (isPrime(x) or isPrime(y)):\n    print(int(a)+int(b))\nelse:\n    print(int(a)*int(b))",
            "syntax_incorrect": "# compile-errors:success: Compilation Successful #\n# compile-result:1 #\n# save-event:compile #\nef a(m,n,T):\n    global cnt\n    cnt += 1\n    if cnt>T:\n        return False\n    elif m == 0:\n        return n+1\n    elif n == 0:\n        return a(m-1,1,T)\n    return a(m-1,a(m,n-1,T),T)\n\nx,y,t = input().split(',')\nm,n,T = int(x),int(y),int(t)\ncnt = 0\n\nres = a(m,n,T)\nif not res:\n    print('Aborted')\nelse:\n    print('Result = {} in {} calls'.format(res,cnt))"
        },
        {
            "semantics_correct": "# compile-errors:success: Compilation Successful #\n# compile-result:1 #\n# save-event:compile #\ndef reverse(Z):\n    numstr=str(Z)\n    reversed=int(numstr[::-1])\n    return reversed\ndef prime(P,i=2):\n     if P <= 2:\n        return True if P == 2 else False\n     if P % i == 0:\n        return False\n     if (i * i > P): \n        return True \n     return prime(P,i+1)\ndef operation(X,Y):\n    if (prime(X) and prime(Y)):\n        print(X + Y)\n    elif (prime(X) or prime(Y)):\n        print(reverse(X) + reverse(Y))\n    else:\n        print(reverse(X) * reverse(Y))\ndta=str(input())\nlst=dta.split(',')\nA=int(lst[0].strip())\nB=int(lst[1].strip())\nX=reverse(A)\nY=reverse(B)\noperation(X,Y)",
            "syntax_incorrect": "# compile-errors:success: Compilation Successful #\n# compile-result:1 #\n# save-event:compile #\ndef reverse(Z):\n    numstr=str(Z)\n    reversed=int(numstr[::-1])\n    return reversed\ndef prime(P,i=2):\n     if P <= 2:\n        return True if P == 2 else False\n     if P % i == 0:\n        return False\n     if (i * i > P): \n        return True \n     return prime(P,i+1)\ndef operation(X,Y):\n    if (prime(X) and prime(Y)):\n        print(X + Y)\n\telif (prime(X) or prime(Y)):\n\t    print(reverse(X) + reverse(Y))\n\telse:\n\t    print(reverse(X) * reverse(Y))\ndta=str(input())\nlst=dta.split(',')\nA=int(lst[0].strip())\nB=int(lst[1].strip())\nX=reverse(A)\nY=reverse(B)\noperation(X,Y)"
        },
        {
            "semantics_correct": "# compile-errors:success: Compilation Successful #\n# compile-result:1 #\n# save-event:compile #\ndef prime(a):\n    if a>1:\n        for i in range(2,a): \n            if (a%i) == 0:\n                return False\n                break\n        else:\n            return True\n\nnum = input()\nnum = num.split(',')\nx, y = (num[0], num[1])\nnum2 = (int(x[::-1]),int(y[::-1]))\nif prime(num2[0]) and prime(num2[1]) == True:\n    print(num2[0] + num2[1])\nelif prime(num2[0]) == True or prime(num2[1]) == True:\n    print(int(x) +int(y))\nelse:\n    print(int(x)*int(y))",
            "syntax_incorrect": "# compile-errors:success: Compilation Successful #\n# compile-result:1 #\n# save-event:compile #\ndef prime(x):\n    if x>1:\n        for i in range(2,x):\n            if x%i ==0:\n                return(False)\n                break\n        else:\n            return(True)\n\n\nnum = input()\nnum = num.split(' ')\nx, y = (num[0], num[1])\nreverse = (int(x[::-1]), int(y[::-1]))\nif prime(reverse[0]) and prime(reverse[1]) == True:\n    print(num[0] + num[1])\nelif prime(reverse[0]) or prime(reverse[1]) == True:\n    print(int(x)+int(y))\nelse prime(reverse[0]) and prime(reverse[1]) == True:\n    print(int(x)*int(y))\n"
        },
        {
            "semantics_correct": "# compile-errors:success: Compilation Successful #\n# compile-result:1 #\n# save-event:compile #\ni1=input()\ni2=i1.strip()\ni3=i2.split(',')\na=int(i3[0])\nb=int(i3[1])\ndef rev (k):\n    s=len(k)-1\n    kr=''\n    while s>=0:\n        kr=kr+k[s]\n        s=s-1\n    return(kr)\nx=int(rev(i3[0]))\ny=int(rev(i3[1]))\ndef prime(p):\n    n=int(p)-1\n    while n>1:\n        if int(p)%n==0:\n            st= False\n            break\n        else:\n            st= True  \n        n=n-1\n    if int(p)==2:\n        st= True\n    if int(p)==1:\n        st= False\n    else:\n        st=st\n    return st\nif prime(x) or prime(y):\n    if prime(x) and prime(y):\n        ou=x+y\n    else:\n        ou=a+b\nelse:\n    ou=a*b\nif a<=10000 and b<=10000 and a>=1 and b>=1:\n    print(ou)\n    ",
            "syntax_incorrect": "# compile-errors:success: Compilation Successful #\n# compile-result:1 #\n# save-event:compile #\ndef prime(a):\n    i=1\n    t=0\n    for i in range(1,a+1):\n        if a%i==0:\n            t=t+1\n    if t==2:\n        return 'true'\n\na=input()\nx=a.replace(' ','')\nx=x.split(',')\na1=x[0]\na2=[x[1]\n#x=prime(a)\nprint (a1,a2)\nif (x=='true'):\n    print (\"prime\")\nelse:\n    print (\"not prime\")"
        },
        {
            "semantics_correct": "# compile-errors:success: Compilation Successful #\n# compile-result:1 #\n# save-event:compile #\ndef isPrime(num):\n    if num<=1:\n        return False\n    for i in range(2, num):\n        if (num % i) == 0:\n            return False\n    return True\n            \na,b = input().split(',')\nx = int(a[::-1])\ny = int(b[::-1])\n\nif (isPrime(x) and isPrime(y)):\n    print(x+y)\n\nelif (isPrime(x) or isPrime(y)):\n    print(int(a)+int(b))\nelse:\n    print(int(a)*int(b))\n",
            "syntax_incorrect": "# compile-errors:success: Compilation Successful #\n# compile-result:1 #\n# save-event:compile #\ni1=input()\ni2=i1.strip()\ni3=i2.split(',')\na=int(i3[0])\nb=int(i3[1])\ndef rev (k):\n    s=len(k)-1\n    kr=''\n    while s>=0:\n        kr=kr+k[s]\n        s=s-1\n    return(kr)\nx=int(rev(i3[0]))\ny=int(rev(i3[1]))\ndef prime(p):\n    n=int(p)-1\n    while n>1:\n        if int(p)%n==0:\n            st= False\n            break\n        else:\n            st= True  \n        n=n-1\n    if int(p)==2:\n        st= True\n    if int(p)==1:\n        st= False\n    else:\n        st=st\n    return st\nif prime(x) or prime(y):\n    if prime(x) and prime(y):\n        ou=x+y\n    else:\n        ou=a+b\nelse:\n    ou=a*b\nif a<=10000 and b<=10000 and a>=1 and b>=1:\n"
        },
        {
            "semantics_correct": "# compile-errors:success: Compilation Successful #\n# compile-result:1 #\n# save-event:compile #\ndef isPrime(num):\n    if num<=1:\n        return False\n    for i in range(2, num):\n        if (num % i) == 0:\n            return False\n    return True\n            \na,b = input().split(',')\nx = int(a[::-1])\ny = int(b[::-1])\n\nif (isPrime(x) and isPrime(y)):\n    print(x+y)\n\nelif (isPrime(x) or isPrime(y)):\n    print(int(a)+int(b))\nelse:\n    print(int(a)*int(b))",
            "syntax_incorrect": "# compile-errors:success: Compilation Successful #\n# compile-result:1 #\n# save-event:compile #\ndef IsPrime(x):\n    count = 0\n    for i in range(1,x+1):\n        if (x%i) == 0:\n            count = count+1\n    if count == 2:\n        return True\n    else:\n        return False\n\n       \ndef Reverse(x):\n    while x%10 == 0:\n        x = x//10\n    rev = 0\n    while(x ! = 0):\n        r = x%10\n        rev = rev*10+r\n        x = x//10\n    return rev\n\n\ndef decrypt(num1,num2):\n    X =Reverse(num1)\n    Y = Reverse(num2)\n    if IsPrime(X) and IsPrime(Y):\n        return X+Y\n    elif IsPrime(X) or IsPrime(Y):\n        return num1+num2\n    else:\n        return num1*num2\n   \npassword=input()\ndec = password.split(',')\nA = int(dec[0])\nB = int(dec[1])\nprint(decrypt(A,B))"
        },
        {
            "semantics_correct": "# compile-errors:success: Compilation Successful #\n# compile-result:1 #\n# save-event:compile #\nI = input()\nJ = I.strip()\nK = J.split(',')\nA = int(K[0])\nB = int(K[1])\n\ndef rev(c):\n    s = len(c) - 1\n    d = ''\n    while s >= 0:\n        d = d + c[s]\n        s = s - 1\n    return(d)\n\nX = int(rev(K[0]))\nY = int(rev(K[1]))\n\ndef prime(p):\n    n = int(p) - 1\n    while n > 1:\n        if int(p) % n == 0:\n            e = False\n            break\n        else:\n            e = True  \n        n = n - 1\n    if int(p) == 2:\n        e = True\n    if int(p) == 1:\n        e = False\n    else:\n        e = e\n    return e\nif prime(X) or prime(Y):\n    if prime(X) and prime(Y):\n        f = X + Y\n    else:\n        f = A + B\nelse:\n    f = A * B\nif 1 <= A <= 10000 and 1 <= B <= 10000:\n    print(f)",
            "syntax_incorrect": "# compile-errors:success: Compilation Successful #\n# compile-result:1 #\n# save-event:compile #\ndef prime(k):\n    if k < 1:\n        return False\n    for i in range(2, k):\n        if k % i == 0:\n            return False\n    return True\n    \nA, B = input().split(',')\nif 1 <= A, B <= 10000:\n    X = int(A[::-1])\n    Y = int(B[::-1])\n\n    if prime(X) and prime(Y):\n        print(X + Y)\n    elif prime(X) or prime(Y):\n        print(int(A) + int(B))\n    else:\n        print(int(A) * int(B))"
        },
        {
            "semantics_correct": "# compile-errors:success: Compilation Successful #\n# compile-result:1 #\n# save-event:compile #\ndef IsPrime(x):\n    count=0\n    for i in range(1,x+1):\n        if (x%i)==0:\n            count=count+1\n    if count==2:\n        return True\n    else:\n        return False\n\n        \ndef Reverse(x):\n    while x%10==0:\n        x=x//10\n    rev=0\n    while(x!=0):\n        r=x%10\n        rev=rev*10+r\n        x= x//10\n    return rev\n\n\ndef decrypt(num1,num2):\n    X=Reverse(num1)\n    Y=Reverse(num2)\n    if IsPrime(X) and IsPrime(Y):\n        return X+Y\n    elif IsPrime(X) or IsPrime(Y):\n        return num1+num2\n    else:\n        return num1*num2\n    \npassword=input()\ndec=password.split(',')\nA=int(dec[0])\nB=int(dec[1])\nprint(decrypt(A,B))\n",
            "syntax_incorrect": "# compile-errors:success: Compilation Successful #\n# compile-result:1 #\n# save-event:compile #\ndef IsPrime(x):\n    count=0\n    for i in range(1,sqrt(x)+1):\n        if((x%i)==0):\n            count++\n    if (count==2):\n        return true\n    else:\n        return false\n        \nif IsPrime(5):\n    print(\"Hello\")"
        },
        {
            "semantics_correct": "# compile-errors:success: Compilation Successful #\n# compile-result:1 #\n# save-event:compile #\ndef Checkprime(x):\n    digit=0\n    for i in range(1,x+1):\n        if (x%i)==0:\n            digit+=1\n    if digit==2:\n        return True\n    else:\n        return False\n\ndef rev(x):\n    y=str(x)\n    z=int(y[::-1])\n    return z\n\ndef condition(no1,no2):\n    X=rev(no1)\n    Y=rev(no2)\n    if Checkprime(X) and Checkprime(Y):\n        return X+Y\n    elif Checkprime(X) or Checkprime(Y):\n        return no1+no2\n    else:\n        return no1*no2\n\nA,B=[int(x) for x in input().split(',')]   \nprint(condition(A,B))\n\n",
            "syntax_incorrect": "# compile-errors:success: Compilation Successful #\n# compile-result:1 #\n# save-event:compile #\ndef Checkprime(x):\n    digit=0\n    for i in range(1,x+1):\n        if (x%i)==0:\n            digit+=1\n    if digit==2:\n        return True\n    else:\n        return False\n\ndef reverse(x):\n    while x%10==0:\n        x=x//10\n    rev=0\n    while x!=0):\n        r=x%10\n        rev=rev*10+r\n        x= x//10\n    return rev\n\n\ndef condition(no1,no2):\n    X=reverse(no1)\n    Y=reverse(no2)\n    if Checkprime(X) and Checkprime(Y):\n        return X+Y\n    elif Checkprime(X) or Checkprime(Y):\n        return no1+no2\n    else:\n        return no1*no2\nA,B=[int(x) for x in input().split(',')]   \nprint(condition(A,B))\n\n"
        },
        {
            "semantics_correct": "# compile-errors:success: Compilation Successful #\n# compile-result:1 #\n# save-event:compile #\nx1= input()\nx2= x1.strip()\nx3= x2.split(',')\nA= int(x3[0])\nB= int(x3[1])\ndef reverse (c):\n    d=len(c)-1\n    e=''\n    while d>=0:\n        e=e+c[d]\n        d=d-1\n    return(e)\na=int(reverse(x3[0]))\nb=int(reverse(x3[1]))\ndef prime(pr):\n    n=int(pr)-1\n    while n>1:\n        if int(pr)%n==0:\n            ans= False\n            break\n        else:\n            ans= True\n        n=n-1\n    if int(pr)==2:\n        ans= True\n    if int(pr)==1:\n        ans= False\n    else:\n        ans=ans\n    return ans\nif prime(a) or prime(b):\n    if prime(a) and prime(b):\n        sol=a+b\n    else:\n        sol=A+B\nelse:\n    sol=A*B\nif A<=10000 and B<=10000 and A>=1 and B>=1:\n    print(sol)",
            "syntax_incorrect": "# compile-errors:success: Compilation Successful #\n# compile-result:1 #\n# save-event:compile #\nx1= input()\nx2= x1.strip()\nx3= x2.split(',')\nA= int(x3[0])\nB= int(x3[1])\ndef rev(c):\n    d=len(c)-1\n    e=''\n    while d>=0:\n        e=e+c[d]\n        d=d-1\n    return(e)\na=int(rev(x3[0])\nb=int(rev(x3[1])\ndef prime(pr):\n    n=int(pr)-1\n    while n>1:\n        if int(pr)%n==0:\n            ans= False\n            break\n        else:\n            ans= True\n        n=n-1\n    if int(pr)==2:\n        ans= True\n    if int(pr)==1:\n        ans= False\n    else:\n        ans=ans\n    return ans\nif prime(a) or prime(b):\n    if prime(a) and prime(b):\n        sol=a+b\n    else:\n        sol=A+B\nelse:\n    sol=A*B\nif A<=10000 and B<=10000 and A>=1 and B>=1:\n    print(sol)"
        },
        {
            "semantics_correct": "# compile-errors:success: Compilation Successful #\n# compile-result:1 #\n# save-event:compile #\ni1=input()\ni2=i1.strip()\ni3=i2.split(',')\na=int(i3[0])\nb=int(i3[1])\ndef rev (k):\n    s=len(k)-1\n    kr=''\n    while s>=0:\n        kr=kr+k[s]\n        s=s-1\n    return(kr)\nx=int(rev(i3[0]))\ny=int(rev(i3[1]))\ndef prime(p):\n    n=int(p)-1\n    while n>1:\n        if int(p)%n==0:\n            st= False\n            break\n        else:\n            st= True  \n        n=n-1\n    if int(p)==2:\n        st= True\n    if int(p)==1:\n        st= False\n    else:\n        st=st\n    return st\nif prime(x) or prime(y):\n    if prime(x) and prime(y):\n        ou=x+y\n    else:\n        ou=a+b\nelse:\n    ou=a*b\nif a<=10000 and b<=10000 and a>=1 and b>=1:\n    print(ou)",
            "syntax_incorrect": "# compile-errors:success: Compilation Successful #\n# compile-result:1 #\n# save-event:compile #\ni1=input()\ni2=i1.strip()\ni3=i2.split(',')\na=int(i3[0])\nb=int(i3[1])\ndef rev (k):\n    s=len(k)-1\n    kr=''\n    while s>=0:\n        kr=kr+k[s]\n        s=s-1\n    return(kr)\nx=int(rev(i3[0]))\ny=int(rev(i3[1]))\ndef prime(p):\n    n=int(p)-1\n    while n>1:\n        if int(p)%n==0:\n            st= False\n            break\n        else:\n            st= True  \n        n=n-1\n    if int(p)==2:\n        st= True\n    else:\n        st=st\n    return st\nif prime(x) or prime(y):\n    if prime(x) and prime(y):\n        ou=x+y\n    else:\n        ou=a+b\nelse:\n    ou=a*b\nif 1<=a,b<=10000:\n    print(ou)"
        },
        {
            "semantics_correct": "# compile-errors:success: Compilation Successful #\n# compile-result:1 #\n# save-event:compile #\ndef isPrime(num):\n    if num<=1:\n        return False\n    for i in range(2, num):\n        if (num % i) == 0:\n            return False\n    return True\n            \na,b = input().split(',')\nx = int(a[::-1])\ny = int(b[::-1])\n\nif (isPrime(x) and isPrime(y)):\n    print(x+y)\n\nelif (isPrime(x) or isPrime(y)):\n    print(int(a)+int(b))\nelse:\n    print(int(a)*int(b))",
            "syntax_incorrect": "# compile-errors:success: Compilation Successful #\n# compile-result:1 #\n# save-event:compile #\ndef IsPrime(x):\n    count=0\n    for i in range(1,x+1):\n        if (x%i)==0:\n            count=count+1\n    if count==2:\n        return True\n    else:\n        return False\n\n       \ndef Reverse(x):\n    while x%10==0:\n        x=x//10\n    rev=0\n        r=x%10\n        rev=rev*10+r\n        Reverse(x // 10)\n    return rev\n\n\ndef decrypt(num1,num2):\n    X=Reverse(num1)\n    Y=Reverse(num2)\n    if IsPrime(X) and IsPrime(Y):\n        return X+Y\n    elif IsPrime(X) or IsPrime(Y):\n        return num1+num2\n    else:\n        return num1*num2\n   \npassword=input()\ndec=password.split(',')\nA=int(dec[0])\nB=int(dec[1])\nprint(decrypt(A,B))"
        },
        {
            "semantics_correct": "# compile-errors:success: Compilation Successful #\n# compile-result:1 #\n# save-event:compile #\ndef Reverse(x):\n    while x%10==0:\n        x=x//10\n        \n    Reverse = 0\n    while(x > 0):\n        Reminder = x%10\n        Reverse = (Reverse *10) + Reminder\n        x=x//10\n    return Reverse\ndef prime(x):\n    count=0\n    for i in range(1,x+1):\n        if(x%i==0):\n            count=count+1\n    if count==2:\n        return True\n    else:\n        return False\n\n\n\ndef crypt(x1,x2):\n    num1=Reverse(x1)\n    num2=Reverse(x2)\n    if prime(num1) and prime(num2):\n        return num1+num2\n    elif prime(num1) or prime(num2):\n        return x1+x2\n    else:\n        return x1*x2\n        \npassword=input()\nde=password.split(',')\nX=int(de[0])\nY=int(de[1])\nprint(crypt(X,Y))",
            "syntax_incorrect": "# compile-errors:success: Compilation Successful #\n# compile-result:1 #\n# save-event:compile #\n\n\ndef Reverse(x):\n    while x%10==0:\n        x=x//10\n        \n    Reverse = 0\n    while(A > 0):\n        Reminder = A %10\n        Reverse = (Reverse *10) + Reminder\n        Num = Number //10\n    return Reverse\n\ndef prime(x):\n    count=0\n    for i in range(1,x+1):\n        if(x%i==0):\n            count=count+1\n        if count==2:\n            return true\n        else:\n            return false\n\ndef crypt(x1,x2):\n    num1=Reverse(x1)\n    num2=Reverse(x2)\n    if prime(num1) and prime(num2):\n        return num1+num2\n    elif:\n        prime(num1) and prime(num2):\n            return x1+x2\n    else:\n        return x1*x2\n        \npassword=input()\nde=password.split(',')\nX=int(de[0])\nY=int(de[1])\nprint(crypt(X,Y))"
        },
        {
            "semantics_correct": "# compile-errors:success: Compilation Successful #\n# compile-result:1 #\n# save-event:compile #\ndef isPrime(num):\n    if num<=1:\n        return False\n    for i in range(2, num):\n        if (num % i) == 0:\n            return False\n    return True\n            \na,b = input().split(',')\nx = int(a[::-1])\ny = int(b[::-1])\n\nif (isPrime(x) and isPrime(y)):\n    print(x+y)\nelif (isPrime(x) or isPrime(y)):\n    print(int(a)+int(b))\nelse:\n    print(int(a)*int(b))",
            "syntax_incorrect": "# compile-errors:success: Compilation Successful #\n# compile-result:1 #\n# save-event:compile #\ndef isPrime(num):\n    if num<=1:\n        return False\n    for i in range(2,num):\n        if (num % i)==0:\n            return False\n    return True\n    \na,b=input().split(',')\nx=int(a[::-1])\ny=int(b[::-1])\n\nif (isPrime(x) and isPrime(y)):\n    print(x+y)\nelif(isPrime(x) or isPrime(y)):\n    print(int(a)+int(b))\n else:\n    print(int(a)*int(b))"
        },
        {
            "semantics_correct": "# compile-errors:success: Compilation Successful #\n# compile-result:1 #\n# save-event:compile #\nlst = input().split(',')\na=lst[0]\nb=lst[1]\ndef prime_chk(num):\n    if num > 1:\n        for i in range(2,num):\n            if (num % i) == 0:\n                return False\n                break\n        else:\n            return True\n    else:\n        return False\ndef decrypter(a,b):\n    x,y = a[::-1], b[::-1]\n    x,y=int(x),int(y)\n    px,py = prime_chk(x),prime_chk(y) \n    if px and py:\n        answer = x+y\n    elif px or py:\n        answer = int(a)+int(b)\n    else:\n        answer = int(a)*int(b)\n    return answer\nprint(decrypter(a,b))",
            "syntax_incorrect": "# compile-errors:success: Compilation Successful #\n# compile-result:1 #\n# save-event:compile #\n1st = input().split(',')\na=1st[0]\nb=1st[1]\ndef prime_chk(num):\n    if num > 1:\n        for i in range(2,num):\n            if (num % i) == 0:\n                return False\n                break\n        else:\n            return True\n    else:\n        return False\ndef decrypter(a,b):\n    x,y = a[::-1], b[::-1]\n    x,y=int(x),int(y)\n    px,py = prime_chk(x),prime_chk(y)\n    if px and py:\n        answer = x+y\n    elif py or py:\n        answer = int(a)+int(b)\n    else:\n        answer = int(a)*int(b)\n    return answer\nprint(decrypter(a,b))"
        },
        {
            "semantics_correct": "# compile-errors:success: Compilation Successful #\n# compile-result:1 #\n# save-event:compile #\nlst = input().split(',')\na=lst[0]\nb=lst[1]\ndef prime_chk(num):\n    if num > 1:\n        for i in range(2,num):\n            if (num % i) == 0:\n                return False\n                break\n        else:\n            return True\n    else:\n        return False\ndef decrypter(a,b):\n    x,y = a[::-1], b[::-1]\n    x,y=int(x),int(y)\n    px,py = prime_chk(x),prime_chk(y) \n    if px and py:\n        answer = x+y\n    elif px or py:\n        answer = int(a)+int(b)\n    else:\n        answer = int(a)*int(b)\n    return answer\nprint(decrypter(a,b))\n",
            "syntax_incorrect": "# compile-errors:success: Compilation Successful #\n# compile-result:1 #\n# save-event:compile #\n1st=input().split(',')\na=lst[0]\nb=lst[1]\ndef prime_chk(num):\n    if num > 1:\n        for i in range(2,num):\n            if (num % i) == 0:\n                return False\n                break\n        else:\n            return True\n    else:\n        return False\ndef decrypter(a,b):\n    x,y = a[::-1], b[::-1]\n    x,y=int(x),int(y)\n    px,py = prime_chk(x),prime_chk(y) \n    if px and py:\n        answer = x+y\n    elif px or py:\n        answer = int(a)+int(b)\n    else:\n        answer = int(a)*int(b)\n    return answer\nprint(decrypter(a,b))\n\n"
        },
        {
            "semantics_correct": "# compile-errors:success: Compilation Successful #\n# compile-result:1 #\n# save-event:compile #\ni1=input()\ni2=i1.strip()\ni3=i2.split(',')\na=int(i3[0])\nb=int(i3[1])\ndef rev (k):\n    s=len(k)-1\n    kr=''\n    while s>=0:\n        kr=kr+k[s]\n        s=s-1\n    return(kr)\nx=int(rev(i3[0]))\ny=int(rev(i3[1]))\ndef prime(p):\n    n=int(p)-1\n    while n>1:\n        if int(p)%n==0:\n            st= False\n            break\n        else:\n            st= True  \n        n=n-1\n    if int(p)==2:\n        st= True\n    if int(p)==1:\n        st= False\n    else:\n        st=st\n    return st\nif prime(x) or prime(y):\n    if prime(x) and prime(y):\n        ou=x+y\n    else:\n        ou=a+b\nelse:\n    ou=a*b\nif a<=10000 and b<=10000 and a>=1 and b>=1:\n    print(ou)",
            "syntax_incorrect": "# compile-errors:success: Compilation Successful #\n# compile-result:1 #\n# save-event:compile #\ndef isPrime(num):\n    if num<=1:\n        return False\n    for i in range (2,num):\n        if (num % i) == 0:\n           return False\n        return True\n        \nm,n=iinput().split(',')\nx=int(m[::-1])\ny=int(n[::-1])\n\nif(isPrime(x) and isPrime(y)):\n    print(x+y)\n    \nelif(isPrime(x) or isPrime(y)):\n    print(int(a)+int(b)\nelse:\n    print(int(a)*int(b)\n"
        },
        {
            "semantics_correct": "# compile-errors:success: Compilation Successful #\n# compile-result:1 #\n# save-event:compile #\ndef IsPrime(x):\n    count=0\n    for i in range(1,x+1):\n        if (x%i)==0:\n            count=count+1\n    if count==2:\n        return True\n    else:\n        return False\n\n       \ndef Reverse(x):\n    while x%10==0:\n        x=x//10\n    rev=0\n    while(x!=0):\n        r=x%10\n        rev=rev*10+r\n        x= x//10\n    return rev\n\n\ndef decrypt(num1,num2):\n    X=Reverse(num1)\n    Y=Reverse(num2)\n    if IsPrime(X) and IsPrime(Y):\n        return X+Y\n    elif IsPrime(X) or IsPrime(Y):\n        return num1+num2\n    else:\n        return num1*num2\n   \npassword=input()\ndec=password.split(',')\nA=int(dec[0])\nB=int(dec[1])\nprint(decrypt(A,B))",
            "syntax_incorrect": "# compile-errors:success: Compilation Successful #\n# compile-result:1 #\n# save-event:compile #\ndef isPrime(num):\n    if num<=1:\n        return False\n    for i in range(2, num):\n        if (num % i) == 0:\n            return False\n    return True\n            a,b = input().split(',')\nx = int(a[::-1])\ny = int(b[::-1])\n\nif (isPrime(x) and isPrime(y)):\n    print(x+y)\n\nelif (isPrime(x) or isPrime(y)):\n    print(int(a)+int(b))\nelse:\n    print(int(a)*int(b))"
        }
    ],
    "IO_example": [
        {
            "IO_number": "19913",
            "input": "142,  123",
            "output": "265\n"
        },
        {
            "IO_number": "19914",
            "input": "4, 16",
            "output": "20\n"
        },
        {
            "IO_number": "19915",
            "input": "4, 61",
            "output": "244\n"
        },
        {
            "IO_number": "19916",
            "input": "2, 3",
            "output": "5\n"
        },
        {
            "IO_number": "19917",
            "input": "2, 13",
            "output": "33\n"
        },
        {
            "IO_number": "19918",
            "input": "2, 543",
            "output": "545\n"
        },
        {
            "IO_number": "19919",
            "input": "2, 543",
            "output": "545\n"
        },
        {
            "IO_number": "19920",
            "input": "2, 2",
            "output": "4\n"
        },
        {
            "IO_number": "19921",
            "input": "2, 2",
            "output": "4\n"
        },
        {
            "IO_number": "19922",
            "input": "7901,   9197",
            "output": "9016\n"
        },
        {
            "IO_number": "19923",
            "input": "1907,   7919",
            "output": "15101533\n"
        },
        {
            "IO_number": "19924",
            "input": "1, 13",
            "output": "14\n"
        }
    ],
    "reference_solution": "def revNum(n):\n    ''' reverse and return reverese of a number encoded as string'''\n    return int(n[::-1])\n\ndef isPrime(n):\n    if n == 2:\n        return True\n    if n == 1:\n        return False\n    if n % 2 == 0:\n        return False\n    i = 3\n    while (i*i <= n):\n        if n % i == 0:\n            return False\n        i += 2\n    return True\n\ndef main():\n    a, b = input().split(',')\n    c, d = revNum(a), revNum(b)\n    a, b = int(a), int(b)\n    if (isPrime(c)): \n        if (isPrime(d)):\n            print(c + d)\n        else:\n            print(a + b)\n    else:\n        if (isPrime(d)):\n            print(a + b)\n        else:\n            print(a * b)\n\nmain()",
    "statement": "You've saved the password to access your Bitcoins on your personal computer. You have created an application that encrypts the password. To decrypt, you need to perform an operation between two integers, say A and B, as described below - \n\n1) Let X and Y be the numbers obtained by REVERSING A and B. For example, the reverse of 123 is 321, and the reverse of 320 is 23 (leading zeroes are discarded)\n\n2) If both X and Y are PRIME, then the answer is X + Y\n\n3) If EXACTLY ONE of X and Y is PRIME, then the answer is A +  B\n\n4) Otherwise, the answer is A * B\n\nYour task is to write a program to help you perform this operation.\n\nInput: Two COMMA-separated integers A and B. There can be any number of white-spaces in the input.\nOutput : A single integer that is the result of applying the operation described above on the input integers.\n\nConstraints:\n$1 \\leq A, B \\leq 10000$\n\nExample:\nInput:\n142 123\nOutput:\n265\n\nExplanation : The reverse of 142 is 241 (prime) and that of 123 is 321 (not prime). Hence the answer is A + B = 142 + 123 = 265\n\nIMPORTANT : Make sure your code is modular i.e. you REUSE as much of the code as possible USING FUNCTIONS. You may LOSE MARKS if this guideline is not followed.",
    "problem_ID": "2882"
}